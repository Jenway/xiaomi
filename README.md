## Day 02

- run `make all`

1. 定义一个图书类，包含书名，作者，版本等信息，并提供修改和获取版本的功能
    - run `./book`
2. 实现一个简单的继承关系，例如一个基类表示动物，派生类表示狗和猫，展示多态的特性
    - run `./animal`

### 运行时多态

- 第二问的多态自然指的是**运行时多态**，也就是基于虚函数的 `override`
- 以使用基类指针（引用）调用子类的普通成员函数为例，函数地址是根据调用指针的类型的记录的偏移量，所以用基类指针自然是会调用基类的函数
- 如果一个类中声明了虚函数，那么该类（无论是基类还是派生类）都会（独立的）生成一张**虚函数表（vtable）**
- 每个实例化的对象都会有一个指向 `vtable` 的指针，这个指针通常位于对象内存布局的最前面
- 调用虚函数时，会先通过对象的虚表指针定位到对应虚表，然后从虚表中查找目标函数的地址
- 两次间接寻址自然会效率差些，存储虚表也会有额外空间消耗
- `Base*` 指向子类对象时，尽管子类的类型信息在编译时被擦除，但由于虚函数表保留了重写信息，在运行时依然能够正确调用到子类重写的函数

### 但是为什么一定要用继承呢？

请 run `./animalProxy`

[Proxy: Next Generation Polymorphism in C++ —— github.com](https://github.com/microsoft/proxy)
